{
  "html": [
    {
      "id": 1,
      "text": "Какой тег используется для создания ссылки?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<link>", "isCorrect": false },
        { "id": 2, "text": "<a>", "isCorrect": true },
        { "id": 3, "text": "<href>", "isCorrect": false },
        { "id": 4, "text": "<anchor>", "isCorrect": false }
      ]
    },
    {
      "id": 2,
      "text": "Какой тег используется для вставки изображения?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<img>", "isCorrect": true },
        { "id": 2, "text": "<picture>", "isCorrect": false },
        { "id": 3, "text": "<media>", "isCorrect": false },
        { "id": 4, "text": "<graphic>", "isCorrect": false }
      ]
    },
    {
      "id": 3,
      "text": "Какой тег находится в <html> определяет заголовок документа?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<head>", "isCorrect": true },
        { "id": 2, "text": "<header>", "isCorrect": false },
        { "id": 3, "text": "<title>", "isCorrect": false },
        { "id": 4, "text": "<meta>", "isCorrect": false }
      ]
    },
    {
      "id": 4,
      "text": "Какой атрибут используется для определения альтернативного текста изображения?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "src", "isCorrect": false },
        { "id": 2, "text": "alt", "isCorrect": true },
        { "id": 3, "text": "title", "isCorrect": false },
        { "id": 4, "text": "href", "isCorrect": false }
      ]
    },
    {
      "id": 5,
      "text": "Какой атрибут позволяет открыть ссылку в новой вкладке?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "target=_blank", "isCorrect": true },
        { "id": 2, "text": "target=blank", "isCorrect": false },
        { "id": 3, "text": "target=_self", "isCorrect": false },
        { "id": 4, "text": "target=_new", "isCorrect": false }
      ]
    },
    {
      "id": 6,
      "text": "Для чего используется атрибут 'placeholder'?",
      "hasOptions": false,
      "answer": "Атрибут 'placeholder' используется для отображения текстовой подсказки или примера ввода в поле формы до того, как пользователь начнет вводить свои данные."
    },
    {
      "id": 7,
      "text": "Как создать непронумерованный список в HTML?",
      "hasOptions": false,
      "answer": "Для создания такого списка в HTML используется тег <code>ul</code>, а для определения каждого пункта списка - тег <code>li</code>."
    },
    {
      "id": 8,
      "text": "Что такое HTML?",
      "hasOptions": false,
      "answer": "HTML (HyperText Markup Language) - это стандартизированный язык разметки, который используется для создания и разработки веб-страниц. Это система для разметки отдельных частей веб-страницы с использованием тегов, заключенных в угловые скобки."
    },
    {
      "id": 9,
      "text": "Что делает тег <!DOCTYPE>?",
      "hasOptions": false,
      "answer": "`Это декларация, которая информирует веб-браузер о версии языка разметки, использованной при создании веб-страницы. Это помогает браузеру корректно отобразить страницу."
    },
    {
      "id": 10,
      "text": "Какой тег используется для создания таблицы?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<table>", "isCorrect": true },
        { "id": 2, "text": "<grid>", "isCorrect": false },
        { "id": 3, "text": "<row>", "isCorrect": false },
        { "id": 4, "text": "<column>", "isCorrect": false }
      ]
    },
    {
      "id": 11,
      "text": "Какой тег используется для создания заголовка таблицы?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<caption>", "isCorrect": false },
        { "id": 2, "text": "<th>", "isCorrect": false },
        { "id": 3, "text": "<thead>", "isCorrect": true },
        { "id": 4, "text": "<title>", "isCorrect": false }
      ]
    },
    {
      "id": 12,
      "text": "Какой тег используется для создания строки таблицы?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<td>", "isCorrect": false },
        { "id": 2, "text": "<row>", "isCorrect": false },
        { "id": 3, "text": "<line>", "isCorrect": false },
        { "id": 4, "text": "<tr>", "isCorrect": true }
      ]
    },
    {
      "id": 13,
      "text": "Какой тег используется для создания ячейки таблицы?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<cell>", "isCorrect": false },
        { "id": 2, "text": "<tr>", "isCorrect": false },
        { "id": 3, "text": "<th>", "isCorrect": false },
        { "id": 4, "text": "<td>", "isCorrect": true }
      ]
    },
    {
      "id": 14,
      "text": "Что такое семантические теги в HTML?",
      "hasOptions": false,
      "answer": "Семантические теги в HTML - это теги, которые передают информацию о смысле или назначении содержимого, а не только о его внешнем виде. Примеры семантических тегов: header, footer, article, section, nav и др. Они помогают создавать более структурированные и доступные веб-страницы."
    },
    {
      "id": 15,
      "text": "Какой атрибут используется для установки фонового изображения?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "background", "isCorrect": false },
        { "id": 2, "text": "background-color", "isCorrect": false },
        { "id": 3, "text": "bgcolor", "isCorrect": false },
        { "id": 4, "text": "background-image", "isCorrect": true }
      ]
    },
    {
      "id": 16,
      "text": "Какой тег используется для создания выпадающего списка?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<dropdown>", "isCorrect": false },
        { "id": 2, "text": "<list>", "isCorrect": false },
        { "id": 3, "text": "<select>", "isCorrect": true },
        { "id": 4, "text": "<option>", "isCorrect": false }
      ]
    },
    {
      "id": 17,
      "text": "Какой тег используется для вставки JavaScript кода в HTML документ?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<javascript>", "isCorrect": false },
        { "id": 2, "text": "<script>", "isCorrect": true },
        { "id": 3, "text": "<js>", "isCorrect": false },
        { "id": 4, "text": "<java>", "isCorrect": false }
      ]
    },
    {
      "id": 18,
      "text": "Какой атрибут используется для указания пути к изображению?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "src", "isCorrect": true },
        { "id": 2, "text": "href", "isCorrect": false },
        { "id": 3, "text": "path", "isCorrect": false },
        { "id": 4, "text": "url", "isCorrect": false }
      ]
    },
    {
      "id": 19,
      "text": "Что делает атрибут 'readonly' в элементе формы?",
      "hasOptions": false,
      "answer": "Атрибут 'readonly' делает элемент формы только для чтения, что значит, что пользователь не может изменять значение элемента, но может просматривать его. Это может быть полезно, если вы хотите отобразить информацию, которая не должна быть изменена."
    },
    {
      "id": 20,
      "text": "Что такое веб-стандарты и зачем они нужны?",
      "hasOptions": false,
      "answer": "Веб-стандарты - это рекомендации, разработанные группами стандартов, такими как W3C или WHATWG, для обеспечения совместимости и устойчивости веб-технологий. Они включают рекомендации по HTML, CSS, JavaScript и другим веб-технологиям. Соблюдение веб-стандартов помогает обеспечить корректную работу веб-страниц в различных браузерах и устройствах, а также облегчить обслуживание и расширение веб-сайтов в будущем."
    },
    {
      "id": 21,
      "text": "Что такое отзывчивый (responsive) веб-дизайн?",
      "hasOptions": false,
      "answer": "Это подход к веб-дизайну, который позволяет веб-страницам корректно отображаться и функционировать на различных устройствах, включая мобильные телефоны, планшеты и настольные компьютеры, путем использования гибких макетов, гибких изображений и CSS медиазапросов для адаптации дизайна к различным размерам экрана и характеристикам устройств."
    },
    {
      "id": 22,
      "text": "Какой тег HTML используется для вставки видео?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<media>", "isCorrect": false },
        { "id": 2, "text": "<video>", "isCorrect": true },
        { "id": 3, "text": "<movie>", "isCorrect": false },
        { "id": 4, "text": "<multimedia>", "isCorrect": false }
      ]
    },
    {
      "id": 23,
      "text": "Какой тег используется для создания главного заголовка на веб-странице?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<h1>", "isCorrect": true },
        { "id": 2, "text": "<header>", "isCorrect": false },
        { "id": 3, "text": "<title>", "isCorrect": false },
        { "id": 4, "text": "<head>", "isCorrect": false }
      ]
    },
    {
      "id": 24,
      "text": "Что делает тег <br>?",
      "hasOptions": false,
      "answer": "Он спользуется для переноса строки, что позволяет создать новую строку в том месте, где он размещен. Это удобный способ управления расположением текста на веб-странице без использования дополнительных стилей или элементов."
    },
    {
      "id": 25,
      "text": "Какой тег используется для создания упорядоченного списка?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<ul>", "isCorrect": false },
        { "id": 2, "text": "<ol>", "isCorrect": true },
        { "id": 3, "text": "<li>", "isCorrect": false },
        { "id": 4, "text": "<list>", "isCorrect": false }
      ]
    },
    {
      "id": 26,
      "text": "Что такое DOM в контексте веб-разработки?",
      "hasOptions": false,
      "answer": "DOM (Document Object Model) - это программный интерфейс для веб-документов. Это представление структурированного документа в виде объектной модели, которое позволяет программам и скриптам взаимодействовать с содержимым, структурой и стилями веб-страницы. DOM представляет документ как дерево объектов, каждый из которых соответствует части страницы."
    },
    {
      "id": 27,
      "text": "Какой атрибут используется для определения стилей элемента на странице?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "style", "isCorrect": true },
        { "id": 2, "text": "css", "isCorrect": false },
        { "id": 3, "text": "styles", "isCorrect": false },
        { "id": 4, "text": "stylesheet", "isCorrect": false }
      ]
    },
    {
      "id": 28,
      "text": "Что такое атрибут 'alt' в теге <img>?",
      "hasOptions": false,
      "answer": "Он используется для предоставления альтернативного текста, который будет отображаться в случае, если изображение не может быть загружено. Это также может быть полезно для обеспечения доступности, поскольку скрин-ридеры могут использовать этот текст для описания изображения пользователям с ограниченными возможностями."
    }
  ],
  "css": [
    {
      "id": 1,
      "text": "В чем разница между «сбросом» и «нормализацией» CSS? Что бы вы выбрали и почему?",
      "hasOptions": false,
      "answer": "Сброс (reset) сбрасывает все встроенные в браузер стили элементов. Normalize приводит стили к единому виду во всех браузерах. Лучше использовать Normalize из-за кроссбраузерности."
    },
    {
      "id": 2,
      "text": "Что такое специфичность селекторов CSS и как она работает?",
      "hasOptions": false,
      "answer": "Специфичность селектора (еще называют весом) это свойство определяющее приоритет стилевого правила, то есть то, какой стиль будет применен к HTML элементу в итоге. Например, используя какую-нибудь UI библиотеку, элементам этой библиотеки будут применены правила заданные авторами по умолчанию. При необходимости можно поменять стили на свои, «перебив» дефолтные более специфичным селектором.\n\nПодробнее тут: <a href='https://developer.mozilla.org/ru/docs/Web/CSS/Specificity' target='_blank'>Специфичность (MDN)</a>"
    },
    {
      "id": 3,
      "text": "Что такое CSS?",
      "hasOptions": false,
      "answer": "CSS (Cascading Style Sheets) - это язык стилей, используемый для описания внешнего вида и форматирования документа, написанного на языке разметки, таком как HTML. CSS позволяет разработчикам управлять макетом, шрифтами, цветами и другими стилистическими аспектами веб-страницы."
    },
    {
      "id": 4,
      "text": "Почему, как правило, лучше разместить подключение CSS в <head>, а <script> перед тэгом </body>? Знаете ли вы какие-либо исключения, приведите примеры?",
      "hasOptions": false,
      "answer": "Стили рекомендуется подключать в head для того, чтобы страница как можно быстрее приняла свой внешний вид. Скрипты подключенные в head могут затормозить этот процесс, в связи с этим их рекомендуется подключать перед закрывающим тегом body. Исключением являются скрипты аналитики, для определения количества посетителей, которые не дождались загрузки страницы. В этом случае скрипт должен быть подключен в head."
    },
    {
      "id": 5,
      "text": "Что делает свойство 'z-index' в CSS?",
      "hasOptions": false,
      "answer": "Свойство 'z-index' в CSS контролирует стековый порядок элементов по оси Z. Элемент с большим значением 'z-index' будет отображаться поверх элемента с меньшим значением 'z-index'."
    },
    {
      "id": 6,
      "text": "Какие есть способы отцентровать div?",
      "hasOptions": false,
      "answer": "Существует несколько способов отцентровать div в CSS, вот некоторые из них: \n1. Использование свойств margin и auto: `margin: 0 auto;`.\n2. Использование Flexbox: `display: flex; justify-content: center; align-items: center;`.\n3. Использование Grid Layout: `display: grid; place-items: center;`.\n4. Использование свойств text-align и inline-block: `text-align: center;` на родительском элементе и `display: inline-block;` на самом div.`."
    },
    {
      "id": 7,
      "text": "Какое свойство используется для установки цвета фона?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "color", "isCorrect": false },
        { "id": 2, "text": "background-color", "isCorrect": true },
        { "id": 3, "text": "bgcolor", "isCorrect": false },
        { "id": 4, "text": "background", "isCorrect": false }
      ]
    },
    {
      "id": 8,
      "text": "Какое свойство позволяет установить внешние отступы элемента?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "padding", "isCorrect": false },
        { "id": 2, "text": "border", "isCorrect": false },
        { "id": 3, "text": "margin", "isCorrect": true },
        { "id": 4, "text": "spacing", "isCorrect": false }
      ]
    },
    {
      "id": 9,
      "text": "Какое свойство используется для установки шрифта?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "font-weight", "isCorrect": false },
        { "id": 2, "text": "font-style", "isCorrect": false },
        { "id": 3, "text": "text-font", "isCorrect": false },
        { "id": 4, "text": "font-family", "isCorrect": true }
      ]
    },
    {
      "id": 10,
      "text": "Какое свойство CSS позволяет контролировать видимость элемента в DOM, но при этом сохраняет его место?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "display: none", "isCorrect": false },
        { "id": 2, "text": "visibility: hidden", "isCorrect": true },
        { "id": 3, "text": "is-visible: 0", "isCorrect": false },
        { "id": 4, "text": "color: transparent", "isCorrect": false }
      ]
    },
    {
      "id": 11,
      "text": "Какое свойство CSS используется для установки теней элементов?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "box-shadow", "isCorrect": true },
        { "id": 2, "text": "text-shadow", "isCorrect": false },
        { "id": 3, "text": "shadow", "isCorrect": false },
        { "id": 4, "text": "border-shadow", "isCorrect": false }
      ]
    },
    {
      "id": 12,
      "text": "Какой селектор выбирает все элементы .child, которые являются непосредственными дочерними элементами .parent?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": ".parent + .child", "isCorrect": false },
        { "id": 2, "text": ".parent ~ .child", "isCorrect": false },
        { "id": 3, "text": ".parent > .child", "isCorrect": true },
        { "id": 4, "text": ".parent .child", "isCorrect": false }
      ]
    },
    {
      "id": 13,
      "text": "Какой селектор CSS выбирает все элементы, которые имеют указанный атрибут, начинающийся с определенной строки?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "[attr=value]", "isCorrect": false },
        { "id": 2, "text": "[attr~=value]", "isCorrect": false },
        { "id": 3, "text": "[attr|=value]", "isCorrect": false },
        { "id": 4, "text": "[attr^=value]", "isCorrect": true }
      ]
    },
    {
      "id": 14,
      "text": "Какой селектор CSS выбирает все элементы, которые имеют указанный атрибут, заканчивающийся определенной строкой?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "[attr=value]", "isCorrect": false },
        { "id": 2, "text": "[attr~=value]", "isCorrect": false },
        { "id": 3, "text": "[attr|=value]", "isCorrect": false },
        { "id": 4, "text": "[attr$=value]", "isCorrect": true }
      ]
    }
  ],
  "javascript": [
    {
      "id": 1,
      "text": "Что такое чистая функция?",
      "hasOptions": false,
      "answer": "Это функция, которая возвращает одинаковый результат, когда вызывается с одним и тем же набором аргументов, а также не имеет побочных эффектов (side effects)"
    },
    {
      "id": 2,
      "text": "Что такое замыкание?",
      "hasOptions": false,
      "answer": "Замыкания – это способность функции запоминать лексическое окружение, в котором она была создана, то есть хранить в себе ссылку на это окружение и обращаться к нему.\n\n<a href='https://youtu.be/mI6Jcfsgma4?si=46DV3mXPF6mDTTPs' target='_blank'>Подробнейшее видео про замыкание</a>"
    },
    {
      "id": 3,
      "text": "let VS const: почему лучше использовать const, когда это возможно?",
      "hasOptions": false,
      "answer": "Использование const дает два преимущества:\n1) Безопасность: объявление переменных через const защищает от неожиданного изменения значения переменной в коде, что может часто приводит к ошибкам и неожиданному поведению программы.\n2) Читаемость: использование const позволяет читателю кода понимать, что значение переменной не будет изменяться в течение выполнения программы. Это делает код более понятным и уменьшает возможность ошибок.\n\nПодробнее: <a href='https://youtu.be/07FllcTRj84?si=q7v60ZvHYBoRSSen' target='_blank'>Видео про VAR/LET/CONST</a>"
    },
    {
      "id": 4,
      "text": "Что такое промисы (Promises) в JavaScript?",
      "hasOptions": false,
      "answer": "Промисы – это объекты, которые представляют результат асинхронной операции. Они могут находиться в одном из трех состояний: ожидание (pending), выполнено (fulfilled) или отклонено (rejected)."
    },
    {
      "id": 5,
      "text": "Что такое деструктуризация в JavaScript?",
      "hasOptions": false,
      "answer": "Деструктуризация позволяет извлекать отдельные свойства из объектов или элементы из массивов и присваивать их переменным в более удобной форме. Например, вот так мы можем одной строкой извлечь имя и адрес пользователя из объекта user:\n<code>const {name, address} = user;</code>"
    },
    {
      "id": 6,
      "text": "Что такое стрелочные функции в JavaScript?",
      "hasOptions": false,
      "answer": "Стрелочные функции — это синтаксически компактный способ записи функций в JavaScript, который не имеет своего собственного 'this'. Они часто используются для создания анонимных функций.\n\n<a href='https://youtu.be/nGVYdna4kq4?si=1k0J9F-MYxWCaq6M' target='_blank'>Подробное видео про функции в JS</a>"
    },
    {
      "id": 7,
      "text": "Что такое hoisting в JavaScript?",
      "hasOptions": false,
      "answer": "Hoisting — это механизм в JavaScript, при котором переменные и объявления функций перемещаются на верх своей области видимости перед выполнением кода."
    },
    {
      "id": 8,
      "text": "Какой метод используется для добавления элемента в массив?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "splice()", "isCorrect": false },
        { "id": 2, "text": "pop()", "isCorrect": false },
        { "id": 3, "text": "shift()", "isCorrect": false },
        { "id": 4, "text": "push()", "isCorrect": true }
      ]
    },
    {
      "id": 9,
      "text": "Какой объект представляет текущее окно браузера?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "document", "isCorrect": false },
        { "id": 2, "text": "screen", "isCorrect": false },
        { "id": 3, "text": "window", "isCorrect": true },
        { "id": 4, "text": "browser", "isCorrect": false }
      ]
    },
    {
      "id": 10,
      "text": "Какой оператор используется для сравнения на строгое равенство?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "==", "isCorrect": false },
        { "id": 2, "text": "===", "isCorrect": true },
        { "id": 3, "text": "=", "isCorrect": false },
        { "id": 4, "text": "!==", "isCorrect": false }
      ]
    },
    {
      "id": 11,
      "text": "Какой метод используется для удаления последнего элемента из массива?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "splice()", "isCorrect": false },
        { "id": 2, "text": "pop()", "isCorrect": true },
        { "id": 3, "text": "shift()", "isCorrect": false },
        { "id": 4, "text": "push()", "isCorrect": false }
      ]
    },
    {
      "id": 12,
      "text": "Какой метод в JavaScript используется для преобразования объекта в строку JSON?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "JSON.stringify()", "isCorrect": true },
        { "id": 2, "text": "JSON.parse()", "isCorrect": false },
        { "id": 3, "text": "JSON.toText()", "isCorrect": false },
        { "id": 4, "text": "JSON.toString()", "isCorrect": false }
      ]
    },
    {
      "id": 13,
      "text": "Какой объект в JavaScript используется для работы с датой и временем?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Time", "isCorrect": false },
        { "id": 2, "text": "Date", "isCorrect": true },
        { "id": 3, "text": "Calendar", "isCorrect": false },
        { "id": 4, "text": "DateTime", "isCorrect": false }
      ]
    },
    {
      "id": 14,
      "text": "Какой метод массива в JavaScript используется для фильтрации элементов по определенному критерию?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "map()", "isCorrect": false },
        { "id": 2, "text": "filter()", "isCorrect": true },
        { "id": 3, "text": "reduce()", "isCorrect": false },
        { "id": 4, "text": "forEach()", "isCorrect": false }
      ]
    },
    {
      "id": 15,
      "text": "Что такое коммутативный закон?",
      "hasOptions": false,
      "answer": "Бинарная операция считается коммутативной, если поменяв местами операнды, вы получаете тот же самый результат."
    },
    {
      "id": 16,
      "text": "Что такое стандарты в JavaScript и какие они бывают?",
      "hasOptions": false,
      "answer": "Специальные наборы правил — стандарты — описывают различные аспекты написания кода. Таких стандартов несколько, самые известные в JavaScript: AirBnb, Standard, Google. Линтеры проверяют код на соответствие стандартам. В JavaScript это eslint."
    },
    {
      "id": 17,
      "text": "Что такое магические числа в JavaScript?",
      "hasOptions": false,
      "answer": "Magic Numbers (магические числа). Числа, происхождение которых невозможно понять без глубокого знания происходящего внутри данного участка кода."
    },
    {
      "id": 18,
      "text": "Что такое конкатенация в JavaScript?",
      "hasOptions": false,
      "answer": "Конкатенация - это процесс объединения (соединения) двух или более строк в одну."
    },
    {
      "id": 19,
      "text": "Что такое интерполяция строк в JavaScript?",
      "hasOptions": false,
      "answer": "это способ вставки значений переменных или выражений непосредственно в строку. Интерполяция работает только со строками в бектиках. Это символ `"
    },
    {
      "id": 20,
      "text": "Что такое индекс в JavaScript?",
      "hasOptions": false,
      "answer": "В контексте массивов и списков индекс - это целое число, которое указывает на позицию элемента в массиве или списке."
    },
    {
      "id": 21,
      "text": "Зачем нужны типы данных?",
      "hasOptions": false,
      "answer": "Для защиты программы от трудноуловимых ошибок. Типы определяют две вещи: возможные (допустимые) значения(Number и BigInt) и набор операций, которые можно выполнять над этим типом."
    },
    {
      "id": 22,
      "text": "Примеры примитивных типов данных и составных?",
      "hasOptions": false,
      "answer": "Number, BigInt и String — это примитивные типы данных. Object - составной тип данных"
    },
    {
      "id": 23,
      "text": "Типизация в JavaScript?",
      "hasOptions": false,
      "answer": "JavaScript — это язык со слабой типизацией. Он знает о существовании разных типов (числа, строки и др.), но относится к их использованию не очень строго, пытаясь преобразовывать информацию, когда это кажется разумным."
    },
    {
      "id": 24,
      "text": "Что такое сигнатура в JavaScript?",
      "hasOptions": false,
      "answer": "Сигнатура определяет входные параметры и их типы, а также выходной параметр и его тип. Документация позволяет понять, сколько аргументов у функции и какого они типа, возвращает ли что-то функция и если да, то какого типа возвращаемое значение."
    },
    {
      "id": 25,
      "text": "Когда функция называется детерминированной?",
      "hasOptions": false,
      "answer": "Функция называется детерминированной тогда, когда для одних и тех же входных параметров она возвращает один и тот же результат. Например, функция, считающая количество символов, детерминированная. Функция console.log() — детерминированная. Дело в том, что она всегда возвращает одно и то же значение для любых входных данных. Это значение undefined, а не то, что печатается на экран, как можно было бы подумать. Печать на экран — побочный эффект."
    },
    {
      "id": 26,
      "text": "Что такое побочный эффект в JavaScript?",
      "hasOptions": false,
      "answer": "Побочным эффектом называют действия, которые изменяют внешнее окружение (среду выполнения). К таким действиям относятся любые сетевые взаимодействия, взаимодействие с файловой системой (чтение и запись файлов), вывод информации на экран и т.д."
    },
    {
      "id": 27,
      "text": "Что такое чистая функция в JavaScript?",
      "hasOptions": false,
      "answer": "Чистая функция — это детерминированная функция, которая не производит побочных эффектов. Такая функция зависит только от своих входных аргументов и всегда ведёт себя предсказуемо."
    },
    {
      "id": 28,
      "text": "Что такое методы в JavaScript?",
      "hasOptions": false,
      "answer": "Методы - это функции, которые находятся внутри свойств. Это означает, что метод можно вызвать как функцию, но при этом он работает как свойство и вызывается через точку."
    },
    {
      "id": 29,
      "text": "Из чего состоит определение функции?",
      "hasOptions": false,
      "answer": "Определение функции состоит из двух частей: собственно определения и присваивания константе"
    },
    {
      "id": 30,
      "text": "Что такое return в JavaScript?",
      "hasOptions": false,
      "answer": "return – особая инструкция, которая берет выражение, записанное справа, и отдает его наружу, тому коду, который вызвал функцию."
    },
    {
      "id": 31,
      "text": "Что такое функции-предикаты?",
      "hasOptions": false,
      "answer": "Функции-предикаты (или функции-вопросы) отвечают на какой-то вопрос и всегда (без исключений!) возвращают либо true, либо false."
    },
    {
      "id": 32,
      "text": "Что такое конъюнкцией и дизъюнкция?",
      "hasOptions": false,
      "answer": "`&&` - означает «И» (в математической логике это называют конъюнкцией) оператор `||` — «ИЛИ» (дизъюнкция)"
    },
    {
      "id": 33,
      "text": "Что такое условные конструкции в JavaScript?",
      "hasOptions": false,
      "answer": "Условные конструкции позволяют изменить поведение программы в зависимости от проверяемых условий. if — конструкция языка, управляющая порядком выполнения инструкций. В скобках ей передается выражение-предикат, а затем описывается блок кода в фигурных скобках. Этот блок кода будет выполнен, только если предикат — истина."
    },
    {
      "id": 34,
      "text": "Что такое тернарный оператор в JavaScript?",
      "hasOptions": false,
      "answer": "Тернарный оператор — единственный в своем роде оператор, требующий три операнда: Общий паттерн выглядит так: <predicate> ? <expression on true> : <expression on false>"
    },
    {
      "id": 35,
      "text": "Для чего нужен break в switch?",
      "hasOptions": false,
      "answer": "break нужен для предотвращения «проваливания». Если его не указать, то после выполнения нужного case выполнение перейдет к следующему case, и так либо до ближайшего break, либо до конца switch. После return никакой код не выполняется, в таких случаях мы можем избавиться от break"
    },
    {
      "id": 36,
      "text": "Что такое массивы в JavaScript?",
      "hasOptions": false,
      "answer": "В JavaScript, массивы - это особый тип объектов, предназначенных для хранения и управления упорядоченными коллекциями данных. Они могут содержать элементы разных типов, и их индексы являются целыми числами, начиная с 0."
    },
    {
      "id": 38,
      "text": "Что такое агрегация в JavaScript?",
      "hasOptions": false,
      "answer": "Агрегацией называются любые вычисления, которые строятся на основе всего набора данных: например, поиск максимального значения, среднего, суммы и так далее."
    },
    {
      "id": 39,
      "text": "Что такое структура данных в JavaScript?",
      "hasOptions": false,
      "answer": "Структура данных — это конкретный способ хранения и организации данных."
    },
    {
      "id": 40,
      "text": "Какие существуют методы в стеке?",
      "hasOptions": false,
      "answer": "((push)(pop)(peekBack)(isEmpty)(size))"
    },
    {
      "id": 41,
      "text": "Что такое идемпоте́нтность в JavaScript?",
      "hasOptions": false,
      "answer": "Идемпоте́нтность — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом."
    },
    {
      "id": 42,
      "text": "Потоки операционной системы и какие они бывают?",
      "hasOptions": false,
      "answer": "При старте любой программы операционная система связывает с ней три потока: STDIN (Standard Input) - стандартный ввод, STDOUT (Standard Output) - отвечает за вывод на экран, STDERR (Standard Error) - вывод ошибок"
    },
    {
      "id": 43,
      "text": "Что такое Git?",
      "hasOptions": false,
      "answer": "Git - это распределенная система управления версиями (Version Control System, VCS), которая предназначена для отслеживания изменений в исходном коде и управления версиями проектов. Она позволяет разработчикам сотрудничать над кодом, откатываться к предыдущим версиям, управлять ветвлением проекта и многими другими задачами, связанными с управлением изменениями."
    },
    {
      "id": 44,
      "text": "Что называют языком программирования?",
      "hasOptions": false,
      "answer": "Языком программирования называют правила, по которым записывается исходный код"
    },
    {
      "id": 45,
      "text": "Что такое компиляция?",
      "hasOptions": false,
      "answer": "Компиляция - это процесс, при котором исходный код программы преобразуется в низкоуровневый машинный код или другой эквивалентный исполняемый код. Компиляция происходит перед выполнением программы."
    },
    {
      "id": 46,
      "text": "Что такое интерпретация в JavaScript?",
      "hasOptions": false,
      "answer": "Интерпретация - это метод выполнения программного кода, при котором исходный код программы анализируется и выполняется построчно или по выражению в реальном времени. Интерпретация происходит в момент выполнения программы."
    },
    {
      "id": 47,
      "text": "Что такое Стандарт ECMAScript?",
      "hasOptions": false,
      "answer": "Стандарт ECMAScript. Это большой и серьезный документ, описывающий устройство языка и поведение во всех возможных ситуациях."
    },
    {
      "id": 48,
      "text": "JavaScript интерпретируемый или компилируемый язык программирования?",
      "hasOptions": false,
      "answer": "JavaScript относится к интерпретируемым языкам. Для его запуска нужна специальная программа – интерпретатор. Например, когда JavaScript код выполняется на сервере, интерпретатором чаще всего выступает Node.js, когда на фронтенде — сам браузер."
    },
    {
      "id": 49,
      "text": "npm - это...?",
      "hasOptions": false,
      "answer": "Утилита npm (node package manager, пакетный менеджер). Она позволяет работать с любым Javascript-проектом как с npm-пакетом."
    },
    {
      "id": 50,
      "text": "Что такое транзитивный зависимости в JavaScript?",
      "hasOptions": false,
      "answer": "Зависимости зависимостей называются транзитивными. Первый запуск установки зависимостей формирует этот package-lock.json. Туда записываются все установленные зависимости, в том числе транзитивные со своими версиями."
    },
    {
      "id": 51,
      "text": "Что такое Prettier?",
      "hasOptions": false,
      "answer": "Prettier - это очень популярный инструмент, автоматически форматирующий код по общепринятым правилам."
    },
    {
      "id": 52,
      "text": "Что такое объект в JavaScript?",
      "hasOptions": false,
      "answer": "Объект – тип данных в JavaScript, с помощью которого представляют связанный набор данных. Объекты — это ссылочный тип данных. То есть переменные и константы хранят не сами объекты (их данные), а ссылку на них. Каждое объявление объекта (в том числе пустого), создает новый объект. Поэтому даже два пустых объекта никогда не равны друг другу"
    },
    {
      "id": 53,
      "text": "Что такое оператор нулевого слияния в JavaScript?",
      "hasOptions": false,
      "answer": "Оператор нулевого слияния (??) — это логический оператор, возвращающий значение правого операнда, если значение левого операнда содержит null или undefined, в противном случае возвращается значение левого операнда."
    },
    {
      "id": 54,
      "text": "Формат JSON?",
      "hasOptions": false,
      "answer": "JSON (JavaScript Object Notation) - это легковесный формат обмена данными. JSON используется для передачи данных между веб-сервером и веб-браузером, а также для обмена данными между разными частями приложений."
    },
    {
      "id": 55,
      "text": "Что такое деструктуризация в JavaScript?",
      "hasOptions": false,
      "answer": "Деструктуризация (destructuring) — специальный синтаксис, позволяющий извлекать части из составных данных. Это удобный способ раскладывать объекты на части. Он позволяет сократить код и сделать его более понятным."
    },
    {
      "id": 56,
      "text": "Что такое ассоциативный массив в JavaScript?",
      "hasOptions": false,
      "answer": "Ассоциативный массив — абстрактный тип данных, с помощью которого хранятся пары ключ-значение. В JavaScript — это Object."
    },
    {
      "id": 57,
      "text": "Что такое хеширование в JavaScript?",
      "hasOptions": false,
      "answer": "Хеширование — операция, которая преобразует любые входные данные в строку (реже число) фиксированной длины. Функция, реализующая алгоритм преобразования, называется «хеш-функцией», а результат называют «хешем» или «хеш-суммой». Наиболее известны CRC32, MD5 и SHA (много разновидностей)."
    },
    {
      "id": 58,
      "text": "Что такое область видимости в JavaScript?",
      "hasOptions": false,
      "answer": "Область видимости (scope) - это концепция, определяющая, где и какие переменные могут быть доступны в определенном участке кода. Области видимости определяют правила доступа к переменным и их жизненный цикл. Существует лексическая и динамическая области видимости."
    },
    {
      "id": 59,
      "text": "Что такое лексическая область видимости в JavaScript?",
      "hasOptions": false,
      "answer": "Лексическая область видимости (также известная как статическая область видимости) - это механизм в языках программирования, который определяет, где переменные доступны или видимы в программе. Она определяет, какие переменные и какие значения им присваиваются, когда код выполняется. "
    },
    {
      "id": 60,
      "text": "Что такое Command-query Separation (CQS)?",
      "hasOptions": false,
      "answer": "Принцип программирования, изобретённый Бертраном Мейером, создателем языка Eiffel. Согласно этому принципу, каждая функция является либо командой, которая выполняет действие (action), либо запросом (query), который извлекает данные, но не тем и другим одновременно. Команда всегда связана с выполнением побочных эффектов, а чистые функции возможны только для запросов."
    },
    {
      "id": 61,
      "text": "Что такое принцип наименьшего удивления?",
      "hasOptions": false,
      "answer": "Принцип наименьшего удивления (Principle of Least Astonishment, PLA) - это принцип в разработке программного обеспечения, который гласит, что поведение программы или компонента должно быть предсказуемым и интуитивно понятным для пользователя или разработчика, основываясь на общих ожиданиях и стандартах."
    },
    {
      "id": 62,
      "text": "Что такое Rest-оператор в JavaScript?",
      "hasOptions": false,
      "answer": "Rest-оператор используется при создании функций. Он позволяет собрать остаточные параметры функции в массив"
    },
    {
      "id": 63,
      "text": "Что такое Spread-оператор в JavaScript?",
      "hasOptions": false,
      "answer": "Spread-оператор используется при вызове функций. Он извлекает элементы из массива и заполняет ими параметры функции при вызове"
    },
    {
      "id": 64,
      "text": "Что такое объекты первого рода (или класса) в JavaScript?",
      "hasOptions": false,
      "answer": "Объекты первого рода (или класса). Им обозначают элементы, которые могут быть переданы в функции, возвращены из функций и присвоены переменным (или константам). К таким элементам относятся любые данные, например числа, строки, массивы или логические значения, любая конструкция языка, например, функции. В JavaScript функции это объекты первого рода"
    },
    {
      "id": 65,
      "text": "Что такое функции высшего порядка в JavaScript?",
      "hasOptions": false,
      "answer": "Функции высшего порядка — это функции, которые либо принимают, либо возвращают другие функции, либо делают всё сразу. Такие функции, как правило, реализуют некий обобщённый алгоритм (например, сортировку), а ключевую часть логики делегируют программисту через функцию."
    },
    {
      "id": 66,
      "text": "Что такое hoisting в JavaScript?",
      "hasOptions": false,
      "answer": "Рекурсивный процесс - это процесс, при котором функция вызывает саму себя внутри своего собственного тела. Каждый новый вызов функции создает новый экземпляр функции, который выполняется независимо от предыдущих вызовов."
    },
    {
      "id": 67,
      "text": "Что такое итеративный процесс в JavaScript?",
      "hasOptions": false,
      "answer": "Итеративный процесс - это процесс, при котором задача разбивается на последовательные итерации или шаги, и каждый шаг выполняется последовательно."
    },
    {
      "id": 68,
      "text": "Что такое абстракция в JavaScript?",
      "hasOptions": false,
      "answer": "Абстракция - это концепция, которая позволяет разрабатывать сложные системы, скрывая детали реализации и предоставляя упрощенный и удобный интерфейс для взаимодействия с этой системой."
    },
    {
      "id": 69,
      "text": "Что такое онтология предметной области в JavaScript?",
      "hasOptions": false,
      "answer": "Описание объектов рассматриваемой области и связей между ними называется онтологией предметной области."
    },
    {
      "id": 70,
      "text": "Что такое интерфейс в JavaScript?",
      "hasOptions": false,
      "answer": "Интерфейсом называют набор функций (их сигнатуры, то есть имена функций, количество и типы входящих параметров, а также возвращаемое значение), не зависящих от конкретной реализации. Абстракция  в случае интерфейсов — это слово, описывающее в первую очередь те данные, с которыми мы работаем."
    },
    {
      "id": 71,
      "text": "Что такое инвариант в JavaScript?",
      "hasOptions": false,
      "answer": "Инвариант в программировании — логическое выражение, определяющее непротиворечивость состояния (набора данных)."
    },
    {
      "id": 72,
      "text": "Что такое нормализация в JavaScript?",
      "hasOptions": false,
      "answer": "Задача приведения дроби к нормальной форме называется нормализацией."
    },
    {
      "id": 73,
      "text": "Что такое дерево в программировании?",
      "hasOptions": false,
      "answer": "Дерево — одна из самых распространённых структур данных в информатике и естественный способ моделирования некоторых предметных областей. Любая иерархия является деревом по определению."
    },
    {
      "id": 74,
      "text": "Что называют объектно-ориентированным программированием?",
      "hasOptions": false,
      "answer": "Подход, в котором код представляет из себя набор объектов, взаимодействующих друг с другом, называется объектно-ориентированным программированием (ООП). Объекты в таком подходе, это не просто тип данных объект, это сущности, которые имеют поведение, то есть методы для работы с ними."
    },
    {
      "id": 75,
      "text": "Что такое инкапсуляция в JavaScript?",
      "hasOptions": false,
      "answer": "Инкапсуляция – это объединение функций и данных в рамках одной структуры, внутреннее состояние которой (данные) скрыто от внешнего мира. Такие функции называют методами"
    },
    {
      "id": 76,
      "text": "Что такое this в JavaScript?",
      "hasOptions": false,
      "answer": "this называется контекстом ссылается на текущий контекст выполнения кода и может изменяться в зависимости от того, где и как оно используется. this дает возможность не только читать данные, но и менять их"
    },
    {
      "id": 77,
      "text": "Что такое связывание в JavaScript?",
      "hasOptions": false,
      "answer": "Связывание (binding) - это процесс определения, на что ссылается ключевое слово this в текущем контексте выполнения кода. Значение this ссылается на тот объект, из которого происходит вызов метода. Метод bind() доступен у функций, и в его задачу входит связывание функции с каким-то контекстом. Результатом выполнения bind() будет новая функция, работающая как и исходная функция, но с привязанным к ней контекстом."
    },
    {
      "id": 78,
      "text": "Что такое apply и call и их разница?",
      "hasOptions": false,
      "answer": "apply() и call(): Эти функции внутри себя делают две вещи: меняют контекст и сразу же производят вызов функции. Разница лишь в том, как они работают с аргументами этих функций: apply() – принимает аргументы в виде массива вторым параметром, а call() ждёт на вход позиционные аргументы."
    },
    {
      "id": 79,
      "text": "Отличие стрелочных функций от обычных?",
      "hasOptions": false,
      "answer": "Стрелочные функции отличаются от обычных не только способом записи. Главное их отличие проявляется в том, как они работают с контекстом. Вкратце: контекст обычных функций зависит от места вызова, а контекст стрелочных функций — от того места, где они были определены. Стрелочная функция не имеет своего контекста, она связывается с лексическим окружением, то есть функцией, внутри которой определена стрелочная функция. Это очень важный момент. Именно функция верхнего уровня задаёт контекст стрелочной функции, а не что-то другое."
    },
    {
      "id": 80,
      "text": "Что такое прототип в JavaScript?",
      "hasOptions": false,
      "answer": "Прототип – это обычный объект, хранящийся в специальном служебном поле [[prototype]] (к этому полю невозможно обратиться напрямую)"
    },
    {
      "id": 81,
      "text": "Что такое ООП в JavaScript?",
      "hasOptions": false,
      "answer": "ООП (Объектно-Ориентированное Программирование) в JavaScript - это методология программирования, которая основана на использовании объектов для организации и структурирования кода. JavaScript поддерживает объектно-ориентированный стиль программирования, и многие из его возможностей основаны на концепциях ООП"
    },
    {
      "id": 82,
      "text": "Что такое шаблон проектирования в JavaScript?",
      "hasOptions": false,
      "answer": "Шаблон проектирования или паттерн (англ. design pattern) в разработке программного обеспечения — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста."
    },
    {
      "id": 83,
      "text": "Что такое паттерн Money?",
      "hasOptions": false,
      "answer": "Паттерн Money – объект-значение, описывающий собой деньги."
    },
    {
      "id": 84,
      "text": "Что такое антипаттерн в JavaScript?",
      "hasOptions": false,
      "answer": "Антипаттерн — такое же типовое решение (потому что им часто пользуются), но создающее больше проблем, чем приносящее пользы. Обычно такие решения возникают из-за непонимания причинно-следственных связей в коде."
    },
    {
      "id": 85,
      "text": "Что такое предметно-ориентированный язык?",
      "hasOptions": false,
      "answer": "Domain Specific Language (Предметно-ориентированный язык) — язык, специализированный под конкретную область применения. Структура такого языка отражает специфику решаемых с его помощью задач. Яркий пример подобного языка — библиотека jQuery"
    },
    {
      "id": 86,
      "text": "Что такое текучий интерфейс в JavaScript?",
      "hasOptions": false,
      "answer": "Текучий интерфейс (англ. fluent interface — в значении «плавный» или «гладкий» «интерфейс») в разработке программного обеспечения — способ реализации объектно-ориентированного API, нацеленный на повышение читабельности исходного кода программы (цепочка методов)"
    },
    {
      "id": 87,
      "text": "Что такое валидация в JavaScript?",
      "hasOptions": false,
      "answer": "Валидация — это процесс проверки данных на корректность по заданным условиям. А валидатор — это что-то, выполняющее данную проверку."
    },
    {
      "id": 88,
      "text": "Что такое принцип SRP в JavaScript?",
      "hasOptions": false,
      "answer": "Принцип SRP - принцип единственной ответственности, S из SOLID. Он говорит следующее: должна быть ровно одна причина для изменения класса"
    },
    {
      "id": 89,
      "text": "Что такое асинхронный код?",
      "hasOptions": false,
      "answer": "Асинхронный код - это код, который выполняется не последовательно, а параллельно или вне основного потока выполнения. Он позволяет выполнять задачи, которые могут занимать много времени, без блокировки основного потока программы. Вместо того, чтобы ждать завершения одной задачи, JavaScript продолжает выполнять другие задачи, и обратится к асинхронной задаче, когда она завершится."
    },
    {
      "id": 90,
      "text": "Что такое hoisting в JavaScript?",
      "hasOptions": false,
      "answer": "Стек вызовов** (Call Stack) в JavaScript - это структура данных, используемая для управления вызовами функций во время выполнения программы. Каждый раз, когда функция вызывается, информация о вызове (локальные переменные, параметры и т. д.) помещается в стек вызовов. Когда функция завершает свое выполнение, соответствующая информация удаляется из стека. Стек вызовов в JavaScript работает по принципу последним вошел, первым вышел (Last In, First Out, **LIFO**). Это означает, что функции, вызванные последними, выполняются первыми, и их вызовы извлекаются из стека в обратном порядке"
    },
    {
      "id": 91,
      "text": "Что такое промис в JavaScript?",
      "hasOptions": false,
      "answer": "Промис — это специальный объект, который отслеживает асинхронную операцию и хранит внутри себя её результат. Это не результат асинхронной операции. Это объект, который отслеживает выполнение операции"
    },
    {
      "id": 92,
      "text": "Что такое BOM в JavaScript?",
      "hasOptions": false,
      "answer": "BOM (Browser Object Model) — это набор глобальных объектов, которые управляют поведением браузера. Все они также находятся внутри window. Разберем некоторые из них."
    },
    {
      "id": 93,
      "text": "Что такое window?",
      "hasOptions": false,
      "answer": "Window - это глобальный объект, предоставляемый браузером. Через него происходит управление окнами (вкладками) в браузере. Он содержит функции для открытия вкладки, управление положением страницы и многим другим"
    },
    {
      "id": 94,
      "text": "Что такое hoisting в JavaScript?",
      "hasOptions": false,
      "answer": "Hoisting"
    },
    {
      "id": 95,
      "text": "Что такое Fetch в JavaScript?",
      "hasOptions": false,
      "answer": "Fetch - это современный метод выполнения AJAX-запросов. Связь с сервером и другими сайтами происходит с помощью функции fetch(). До появления HTML5, браузеры предоставляли специальный объект XMLHttpRequest"
    },
    {
      "id": 96,
      "text": "Для чего нужно DOM-дерево?",
      "hasOptions": false,
      "answer": "Дело в том, что HTML — это просто текст. Использовать его напрямую крайне неудобно. Фактически, это невозможно. Гораздо проще создать на его основе объект, который будет соответствовать структуре самого HTML, а затем использовать его для генерации страницы. Таким объектом и является DOM-дерево."
    },
    {
      "id": 97,
      "text": "Что такое DOM-дерево?",
      "hasOptions": false,
      "answer": "Объектная модель документа (Document Object Model) — это независимый от платформы и языка формат, который позволяет программам и скриптам получать доступ к содержимому HTML-документов, а также изменять их содержимое, структуру и дизайн."
    },
    {
      "id": 98,
      "text": "Для чего нужны полифиллы?",
      "hasOptions": false,
      "answer": "JavaScript позволяет частично компенсировать недостатки старых браузеров. Благодаря прототипам разработчики могут добавить недостающую функциональность прямо в реализацию DOM. Делается это с помощью полифиллов"
    },
    {
      "id": 99,
      "text": "Что такое перехват и всплытие в JavaScript?",
      "hasOptions": false,
      "answer": "Перехват (capturing) и всплытие (bubbling) - это два этапа процесса обработки событий в DOM (Document Object Model) в JavaScript. Эти этапы позволяют событиям распространяться от корневого элемента DOM к целевому элементу (перехват) и затем обратно от целевого элемента к корневому (всплытие)"
    },
    {
      "id": 100,
      "text": "Подробно про перехват?",
      "hasOptions": false,
      "answer": "Перехват (capturing)** В этой фазе событие начинает свой путь с корневого элемента DOM и движется вниз к целевому элементу. В это время событие проходит через все элементы на пути, и обработчики, установленные на этапе перехвата, вызываются. По умолчанию этап перехвата отключен (false), но вы можете включить его, установив параметр **`true`** при вызове **`addEventListener`."
    },
    {
      "id": 101,
      "text": "Подробно про высплытие(event bubbling)?",
      "hasOptions": false,
      "answer": "Всплытие (bubbling) После того как событие достигло целевого элемента, оно начинает путь в обратную сторону, всплывая от целевого элемента к корневому. В это время событие также проходит через все элементы на пути, и обработчики, установленные на этапе всплытия, вызываются. Этап всплытия является стандартным для событий, если вы не указываете иное. Перехват — это механизм передачи события обработчику. При погружении или всплытии событие переходит от одного элемента другому. Если в элементе есть обработчик этого события, то он вызывается — происходит перехват события обработчиком. Можно остановить двумя способами: event.stopPropagation() — останавливает всплытие, но позволяет доработать всем обработчикам, которые висят на текущем элементе\nevent.stopImmediatePropagation() — останавливает всплытие вместе со всеми обработчиками"
    },
    {
      "id": 102,
      "text": "События в JavaScript?",
      "hasOptions": false,
      "answer": "Cуществует ряд событий, которые привязаны к работе самого браузера. К таким событиям относятся события на загрузку и выгрузку страницы: beforeunload – пользователь пытается уйти со страницы. load – все ресурсы загружены (картинки, стили, скрипты и так далее) DOMContentLoaded – DOM-дерево полностью построено и готово к работе, без ожидания полной загрузки таблиц стилей, изображений и фреймов. Иногда скрипты могут запускаться до того, как готов DOM, от которого они зависят. В таком случае возникают ошибки. Но если при этом использовать событие DOMContentLoaded, то ошибок можно избежать"
    },
    {
      "id": 103,
      "text": "Что такое CORS?",
      "hasOptions": false,
      "answer": "CORS (Cross-Origin Resource Sharing - это механизм веб-безопасности, который позволяет веб-страницам в одном домене запрашивать ресурсы (например, данные или изображения) с серверов в других доменах."
    },
    {
      "id": 104,
      "text": "Что такое AJAX?",
      "hasOptions": false,
      "answer": "AJAX (Asynchronous JavaScript and XML) -Механизм для выполнения HTTP-запросов прямо из браузера "
    },
    {
      "id": 105,
      "text": "Что такое регулярные выражения?",
      "hasOptions": false,
      "answer": "Регулярные выражения — это формальный язык, который используется для поиска символов и манипуляций с подстроками. Это мощный инструмент, который позволяет эффективно работать с текстом."
    },
    {
      "id": 106,
      "text": "Что такое явное связывание в JavaScript?",
      "hasOptions": false,
      "answer": "Явное связывание происходит, когда программист явно указывает, к какому объекту должна быть привязана функция с помощью методов, таких как call(), apply(), и bind(). При использовании явного связывания, контекст выполнения функции определяется явно."
    },
    {
      "id": 107,
      "text": "Что неявное связывание в JavaScript?",
      "hasOptions": false,
      "answer": "Неявное связывание происходит, когда контекст выполнения функции определяется автоматически на основе объекта, в контексте которого функция была вызвана. Обычно это происходит при вызове методов объектов. Контекст является неявным, так как он не требует явной установки."
    },
    {
      "id": 108,
      "text": "Что такое event Loop в JavaScript?",
      "hasOptions": false,
      "answer": "Event Loop (цикл событий) - это часть асинхронной модели выполнения JavaScript, которая управляет обработкой событий, а также выполнением асинхронного кода. Event Loop позволяет JavaScript выполнять операции ввода-вывода (I/O), асинхронные задачи, обработку событий и многое другое, не блокируя основной поток выполнения кода. В основе Event Loop лежит циклический процесс, который выполняется в браузере или на сервере Node.js. Он следит за очередью задач и выполнением событий и обеспечивает, чтобы асинхронные операции выполнялись в правильной последовательности."
    },
    {
      "id": 109,
      "text": "Что такое макротаски в JavaScript?",
      "hasOptions": false,
      "answer": "Макротаски (macrotasks): Это задачи, которые представляют собой общие операции, такие как обработка событий пользовательского интерфейса, выполнение скриптов, сетевые запросы и другие."
    },
    {
      "id": 110,
      "text": "Что такое Микротаски в JavaScript?",
      "hasOptions": false,
      "answer": "Микротаски (microtasks): Это более легкие задачи, обычно связанные с обработкой обещаний (Promises) и выполнением кода, связанного с обработкой результатов асинхронных операций."
    },
    {
      "id": 111,
      "text": "Цикл отрисовки веб-страницы, также известный как рендеринговый цикл или цикл перерисовки?",
      "hasOptions": false,
      "answer": "Построение DOM (Document Object Model): Браузер анализирует HTML-код веб-страницы и создает иерархическую структуру, известную как DOM. DOM представляет собой дерево объектов, где каждый элемент страницы представлен узлом в этом дереве. Построение CSSOM (CSS Object Model): Браузер анализирует CSS-код и создает CSSOM, который описывает стили и макет элементов на странице. Формирование Render Tree (Дерево отображения): Браузер объединяет DOM и CSSOM в одну структуру, называемую Render Tree. Render Tree содержит информацию о том, как элементы должны быть отображены на экране, включая их позицию, размер и стили. Расчет макета (Layout): На этом этапе браузер определяет, как элементы будут расположены на экране. Это включает в себя расчет размеров и позиций элементов на основе информации из Render Tree. Отрисовка (Painting): Браузер использует полученную информацию о макете для непосредственной отрисовки пикселей на экране. Это включает в себя рисование текста, цветов, изображений и других элементов. Обработка анимаций и взаимодействий: В случае, если на странице есть анимации или взаимодействия, браузер следит за обновлениями и перерисовывает только измененные части страницы. Обработка событий: Браузер также непрерывно обрабатывает события, такие как клики, наведение курсора, клавишные нажатия и другие, чтобы реагировать на действия пользователя."
    },
    {
      "id": 112,
      "text": "Какие шаблоны проектирование существуют?",
      "hasOptions": false,
      "answer": "Создатель (Builder): Разделяет процесс создания сложного объекта от его представления, позволяя создавать разные представления одного объекта. Адаптер (Adapter):** Позволяет объектам с несовместимыми интерфейсами работать вместе. Фабричный метод (Factory Method):** Определяет интерфейс для создания объектов, но позволяет подклассам выбирать класс создаваемого экземпляра."
    },
    {
      "id": 113,
      "text": "Как фронтенд взаимодействуют с бэкендом?",
      "hasOptions": false,
      "answer": "Фронтенд взаимодействует с бэкендом через HTTP запросы, используя API для отправки и получения данных. Также фронтенд может использовать AJAX для асинхронных запросов, WebSocket для реального времени, и отправку форм для передачи данных. Аутентификация и авторизация контролируют доступ, а отправка файлов позволяет передавать мультимедийные данные."
    },
    {
      "id": 114,
      "text": "Как передаются cookie? В теле или в заголовках?",
      "hasOptions": false,
      "answer": "В заголовках"
    },
    {
      "id": 115,
      "text": "Почему JavaScript мультипарадигменный?",
      "hasOptions": false,
      "answer": "JavaScript мультипарадигменный, потому что он поддерживает несколько различных стилей программирования, включая императивное, декларативное, объектно-ориентированное, функциональное, событийно-ориентированное, асинхронное и модульное программирование. Это делает JavaScript гибким и подходящим для разнообразных задач и проектов."
    },
    {
      "id": 116,
      "text": "Что такое eval в JavaScript?",
      "hasOptions": false,
      "answer": "eval - это функция в JavaScript, которая выполняет строку как код. Она может быть опасной и затруднять отладку, поэтому редко рекомендуется использовать в реальных приложениях."
    },
    {
      "id": 117,
      "text": "Что такое препроцессоры и для чего они нужны?",
      "hasOptions": false,
      "answer": "Препроцессоры - это инструменты, которые расширяют функциональность базовых языков программирования или языков разметки, добавляя дополнительные возможности и упрощая написание кода. Они обычно используются для улучшения эффективности и гибкости разработки."
    }
  ],
  "react": [
    {
      "id": 1,
      "text": "Что такое React JS?",
      "hasOptions": false,
      "answer": "React JS, или просто React, это открытая библиотека JavaScript для создания пользовательских интерфейсов, особенно для одностраничных приложений (SPA). Ключевые особенности React:\n1) Компонентный подход: React строится на концепции компонентов, что позволяет разработчикам создавать легко переиспользуемые куски кода;\n2) Виртуальный DOM: React использует виртуальный DOM для отслеживания изменений. Это абстракция реального DOM, что позволяет библиотеке обновлять только те части интерфейса, которые действительно изменились, вместо полного перерендеринга страницы. Это делает React относительно быстрым;\n3) Хуки: Введение хуков позволило использовать состояния и другие возможности классовых компонентов в функциональных компонентах, что сделало код более кратким и чистым;\n4) Сообщество и экосистема: React имеет большое и активное сообщество разработчиков, а также много библиотек и инструментов, созданных сообществом, что облегчает разработку сложных приложений.\n\nПодробнее: <a href='https://youtu.be/R_39q-vdOaE?si=mEKDaYDjEdnojG-N' target='_blank'>Введение в React (видео)</a>"
    },
    {
      "id": 2,
      "text": "Для чего нужен атрибут key при рендере списков?",
      "hasOptions": false,
      "answer": "Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени. Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Лучше всего вы будете использовать ID из ваших данных как ключи. Индексы массива тоже можно использовать для этого, но только если элементы массива не добавляются в начало, не переставляются и не удаляются."
    },
    {
      "id": 3,
      "text": "Как работает проп children?",
      "hasOptions": false,
      "answer": "Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов можно использовать специальный проп children, который передаст дочерние элементы сразу на вывод.\n\nПодробнее: <a href='https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children' target='_blank'>Документация React (eng)</a>"
    },
    {
      "id": 4,
      "text": "Что такое порталы в React?",
      "hasOptions": false,
      "answer": "Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента. Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно, чтобы дочерний элемент визуально выходил за рамки своего контейнера. Чаще всего, это диалоговые окна, всплывающие карточки и всплывающие подсказки."
    },
    {
      "id": 5,
      "text": "Что такое Reconciliation (Cверка)?",
      "hasOptions": false,
      "answer": "Это процесс, посредством которого React обновляет DOM. Когда состояние компонента изменяется, React должен рассчитать необходимость обновления DOM. Это делается путем создания виртуального DOM и сравнения его с текущим DOM. В этом контексте виртуальный DOM будет содержать новое состояние компонента."
    },
    {
      "id": 6,
      "text": "Для чего используется хук useEffect в React?",
      "hasOptions": true,
      "options": [
        {
          "id": 1,
          "text": "Хранения состояния компонента",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Выполнения побочных эффектов",
          "isCorrect": true
        },
        { "id": 3, "text": "Мемоизации значений", "isCorrect": false },
        {
          "id": 4,
          "text": "Создания ссылок на DOM элементы",
          "isCorrect": false
        }
      ]
    },
    {
      "id": 7,
      "text": "Что будет, если вторым аргументом в useEffect передать пустой массив []?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Ошибка", "isCorrect": false },
        {
          "id": 2,
          "text": "useEffect будет запущен 0 раз",
          "isCorrect": false
        },
        { "id": 3, "text": "useEffect будет запущен 1 раз", "isCorrect": true },
        { "id": 4, "text": "Нет верного ответа", "isCorrect": false }
      ]
    },
    {
      "id": 8,
      "text": "Какой хук используется для создания состояния в компоненте?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "useEffect", "isCorrect": false },
        { "id": 2, "text": "useState", "isCorrect": true },
        { "id": 3, "text": "useContext", "isCorrect": false },
        { "id": 4, "text": "useReducer", "isCorrect": false }
      ]
    },
    {
      "id": 9,
      "text": "Какой элемент используется для группировки элементов без добавления дополнительных узлов в DOM?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<Group>", "isCorrect": false },
        { "id": 2, "text": "<Div>", "isCorrect": false },
        { "id": 3, "text": "<Fragment> (<>)", "isCorrect": true },
        { "id": 4, "text": "<List>", "isCorrect": false }
      ]
    },
    {
      "id": 10,
      "text": "У нас есть массив со строками (arr), каждую из которых мы хотим отразить на странице. Какой метод массива нужно применить в return компонента?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "{arr.forEach(...)}", "isCorrect": false },
        { "id": 2, "text": "{arr.filter(...)}", "isCorrect": false },
        { "id": 3, "text": "{arr.for(...)}", "isCorrect": false },
        { "id": 4, "text": "{arr.map(...)}", "isCorrect": true }
      ]
    },
    {
      "id": 11,
      "text": "Какой элемент используется для обработки ошибок в дереве компонентов?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "ErrorBoundary", "isCorrect": true },
        { "id": 2, "text": "CatchError", "isCorrect": false },
        { "id": 3, "text": "ErrorWrapper", "isCorrect": false },
        { "id": 4, "text": "ErrorCatcher", "isCorrect": false }
      ]
    },
    {
      "id": 12,
      "text": "Какой (какие) аргумент(ы) принимает хук useMemo?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Функцию и массив зависимостей", "isCorrect": true },
        { "id": 2, "text": "Функцию и объект опций", "isCorrect": false },
        { "id": 3, "text": "Функцию", "isCorrect": false },
        { "id": 4, "text": "Массив зависимостей", "isCorrect": false }
      ]
    },
    {
      "id": 13,
      "text": "Для чего используется хук useCallback в React?",
      "hasOptions": true,
      "options": [
        {
          "id": 1,
          "text": "Создания ссылок на DOM элементы",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Хранения состояния компонента",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Выполнения побочных эффектов",
          "isCorrect": false
        },
        { "id": 4, "text": "Мемоизации функций", "isCorrect": true }
      ]
    },
    {
      "id": 14,
      "text": "Какие методы жизненного цикла компонент вы знаете?",
      "hasOptions": false,
      "answer": "В React компоненты имеют ряд методов жизненного цикла, которые позволяют управлять процессом создания, обновления и удаления компонентов.React автоматически вызывает ответственный метод в соответствии с фазой, в которой находится компонент:\n1) Mounting (Монтирование):\nconstructor(): Вызывается при создании экземпляра компонента. Хорошее место для инициализации состояния и привязки методов.\nrender(): Обязательный метод, возвращающий React элемент для отображения. Он должен быть чистой функцией без побочных эффектов.\ncomponentDidMount(): Вызывается сразу после рендеринга компонента в DOM. Хорошее место для выполнения сетевых запросов и инициализации библиотек.\n2)Updating (Обновление):\nshouldComponentUpdate(): Вызывается перед перерисовкой компонента. Может использоваться для оптимизации производительности, предотвращая перерисовку компонента, если это не требуется.\nrender(): Снова вызывается для перерисовки компонента.\ngetSnapshotBeforeUpdate(): Вызывается перед обновлением DOM после того, как компонент был перерисован. Может использоваться для получения информации о DOM до того, как он изменится.\ncomponentDidUpdate(): Вызывается после обновления компонента в DOM. Хорошее место для выполнения дополнительных действий после обновления, например, для работы с DOM элементами или выполнения сетевых запросов.\n3)Unmounting (Размонтирование):\ncomponentWillUnmount(): Вызывается перед тем, как компонент будет удален из DOM. Хорошее место для выполнения необходимых очисток, например, отмены подписок на события или очистки таймеров.\n\nКроме того, существуют некоторые другие методы, такие как componentDidCatch() для обработки ошибок в компонентах и getDerivedStateFromError() для обновления состояния компонента в случае ошибки в дочерних компонентах."
    },
    {
      "id": 15,
      "text": "Отличия функциональных и классовых компонентов в React?",
      "hasOptions": false,
      "answer": "Функциональные компоненты:\nОпределяются как функции JavaScript.\nМогут использовать хуки для работы с состоянием и жизненным циклом.\nОбычно более краткие и лаконичные.\nКлассовые компоненты:\nОпределяются как классы JavaScript, расширяющие React.Component.\nИмеют внутреннее состояние.\nИспользуют методы жизненного цикла React.\nОбычно более объемные и могут быть менее читаемыми."
    },
    {
      "id": 16,
      "text": "Что такое неконтролируемые компоненты?",
      "hasOptions": false,
      "answer": "Неконтролируемые компоненты в React - это компоненты, у которых значение контролируется непосредственно DOM-элементом, а не компонентом React. Они используются тогда, когда нужно интегрировать React с существующим кодом или библиотеками, которые не работают с React. Примером неконтролируемого компонента может быть <input type='text'>, у которого значение устанавливается через атрибут value в DOM, а не через свойство value в React компоненте"
    },
    {
      "id": 17,
      "text": "Что такое Refs?",
      "hasOptions": false,
      "answer": "Refs в React представляют собой специальный атрибут, который используется для получения прямого доступа к DOM-элементу или экземпляру компонента в дереве React. Они предоставляют возможность обращаться к конкретным элементам или компонентам непосредственно в коде React."
    },
    {
      "id": 18,
      "text": "Как в React отлавливать ошибки??",
      "hasOptions": false,
      "answer": "В React для отлова ошибок используется механизм под названием 'Границы ошибок' (Error Boundaries).Чтобы создать границу ошибок, необходимо определить компонент, который реализует методы componentDidCatch(error, info) Чтобы использовать границу ошибок, нужно обернуть свой компонент внутри ErrorBoundary"
    },
    {
      "id": 19,
      "text": "Что такое React?",
      "hasOptions": false,
      "answer": "React - JavaScript фронтенд библиотека, в ядре - компонентный подход, позволяющий создавать переиспользуемые UI блоки"
    },
    {
      "id": 20,
      "text": "Что такое JSX?",
      "hasOptions": false,
      "answer": "Это специальный синтаксис, который расширяет JavaScript возможностью писать HTML внутри"
    },
    {
      "id": 21,
      "text": "Что такое Virtual DOM в React?",
      "hasOptions": false,
      "answer": "Virtual DOM - легковесный JavaScript объект, который представляет копию реального DOM дерева. Нужен для оптимизации взаимодействия с DOM."
    },
    {
      "id": 22,
      "text": "Что такое Props?",
      "hasOptions": false,
      "answer": "Сокращенно от Properties. Входящие свойства в компонент. Они только для чтения и их нельзя менять. Всегда идут от родителя к ребенку."
    },
    {
      "id": 23,
      "text": "Что такое refs в React?",
      "hasOptions": false,
      "answer": "Специальный атрибут, позволяющий получить доступ до конкретного DOM элемента. Нужен для: вызова анимации, для задания фокуса или выделения текста, взаимодействия со сторонними библиотеками."
    },
    {
      "id": 24,
      "text": "Что такое JEST?",
      "hasOptions": false,
      "answer": "JavaScript фреймворк, для юнит тестирования на основе Jasmine."
    },
    {
      "id": 25,
      "text": "Когда следует использовать Class компоненты, а когда функциональные?",
      "hasOptions": false,
      "answer": "Если нужны жизненные этапы компонента - используем class компоненты. Иначе для оптимизации лучше функциональные"
    },
    {
      "id": 26,
      "text": "Что происходит, когда вы вызываете setState?",
      "hasOptions": false,
      "answer": "Вначале React соединяет объект стейта с измененными полями. На основе нового состояния строит новое дерево React элементов и выясняет, какие именно части приложения должны быть изменены. Это нужно для наиболее производительного обновления интерфейса."
    },
    {
      "id": 27,
      "text": "В чем разница между state и props?",
      "hasOptions": false,
      "answer": "State - структура данных, необходимая для изменения и отслеживания пользовательских действий. props- набор конфигурации, поступающий от родительского элемента. Их нельзя изменять."
    },
    {
      "id": 28,
      "text": "Как делать асинхронные запросы на сервер в React?",
      "hasOptions": false,
      "answer": "Для этого служит метод componentDidMount. Или useEffect с пустым набором зависимостей"
    },
    {
      "id": 29,
      "text": "В чем смысл специального атрибута key?",
      "hasOptions": false,
      "answer": "Атрибут позволяет React понимать, какие именно элементы в списке были модифицированы или удалены, что увеличивает производительность рендеринга."
    },
    {
      "id": 30,
      "text": "ЧНазовите разницу между контролируемым и неконтролируемым компонентом?",
      "hasOptions": false,
      "answer": "Контролируемый компонент обладает своим стейтом, управляемый React. Неконтролируемые компоненты обладают внутренним стейтом (как пример значение тега textarea)"
    },
    {
      "id": 31,
      "text": "Что такое фрагменты?",
      "hasOptions": false,
      "answer": "Фрагмент (Fragment) - это компонент React, который позволяет группировать несколько элементов без создания лишних узлов в DOM. Он позволяет рендерить несколько элементов как один компонент без использования обертывающего элемента, такого как div."
    },
    {
      "id": 32,
      "text": "Как React обрабатывает пользовательские события?",
      "hasOptions": false,
      "answer": "React обрабатывает пользовательские события с использованием синтетических событий (Synthetic Events), которые представляют собой обертки над нативными браузерными событиями. Это позволяет React абстрагировать от различий между разными браузерами и обеспечить единый интерфейс для работы с событиями в различных окружениях. Когда вы объявляете обработчик события в React, например, onClick, React создает синтетическое событие и передает его в ваш обработчик. Это событие является объектом, который имеет те же свойства и методы, что и нативное событие браузера, такие как target, currentTarget, preventDefault(), stopPropagation() и так далее."
    },
    {
      "id": 33,
      "text": "Назовите основные этапы жизненного цикла компонента",
      "hasOptions": false,
      "answer": "componentWillMount- перед рендерингом, в основном для настройки компонента. render- процесс рендеринга. componentDidMount- уведомляет, про то, что компонент соединен с DOM деревом. componentWillReceiveProps- уведомляет, про то, что приходят новые входящие свойства в компонент. shouldComponentUpdate- возвращает true или false и служит для оптимизации. Решает, нужно ли делать ре-рендеринг. componentWillUpdate- уведомляет, что компонент будет обновлен. componentDidUpdate- уведомляет, что компонент был обновлен. componentWillUnmount- используется для удаления слушателей и очистки компонента. Вызывается перед удалением компонента"
    },
    {
      "id": 34,
      "text": "Что такое Higher-Order компоненты?",
      "hasOptions": false,
      "answer": "Higher-order component (HOC) - функции, у которых входящий параметр компонент. Возвращают новый компонент с добавленным поведением. Служат для: Переиспользование кода. Слой абстракции для state и взаимодействия с ним. Управление props"
    },
    {
      "id": 35,
      "text": "Что такое store в Redux?",
      "hasOptions": false,
      "answer": "JavaScript объект, в котором содержится состояние приложения. Дополнительно отвечает за следующее: state может быть получен через getState(). Изменять state можно через dispatch(action). Регистрировать изменения через subscribe(listener)"
    },
    {
      "id": 36,
      "text": "Что такое action в Redux?",
      "hasOptions": false,
      "answer": "Объект, который обязательно должен содержать ключ type. С помощью него Redux понимает, что именно нужно сделать со стейтом"
    },
    {
      "id": 37,
      "text": "Что такое React Hooks?",
      "hasOptions": false,
      "answer": "React Hooks - это новая функциональность в библиотеке React, которая позволяет использовать состояние и другие возможности React в функциональных компонентах. Hooks предоставляют более простой способ управления состоянием и жизненным циклом компонентов без необходимости использования классов."
    },
    {
      "id": 38,
      "text": "В чем разница между useRef и createRef?",
      "hasOptions": false,
      "answer": "createRef- всегда создает новую ссылку. Используется в class компонентах useRef- возвращает одинаковую ссылку на объект, которое были при начальном рендеринге"
    },
    {
      "id": 39,
      "text": "Что такое react fiber?",
      "hasOptions": false,
      "answer": "React Fiber - это новый алгоритм, который был введен в версии 16 и он улучшает производительность и реактивность пользовательского интерфейса. Он разбивает выполнение задач на более мелкие части, которые могут быть приостановлены и продолжены в любой момент времени. Это позволяет React более гибко управлять приоритетами и временем выполнения задач."
    },
    {
      "id": 40,
      "text": "Что такое синтетические события в React?",
      "hasOptions": false,
      "answer": "Синтетические события в React - это кроссбраузерная обертка для нативных событий браузера, то есть любые события с которыми работает Реакт являются не нативными, а всего лишь обертками. Данный API полностью аналогичен браузерному, однако синтетические события работают одинаково во всех браузерах, что помогает в кроссбраузерности т.к. не требуются фолбеки или полифилы."
    },
    {
      "id": 41,
      "text": "Разница между теневым (Shadow) и виртуальным (Virtual) DOM?",
      "hasOptions": false,
      "answer": "Теневой (Shadow) DOM - это изолированный участок дерева DOM, часть web API, которое может быть создано и использовано внутри компонента веб-приложения. Он позволяет создавать компоненты с собственным стилем и поведением, которые могут быть вложены в другие компоненты без конфликтов стилей и поведения за счет того что они изолированы от дерева DOM. Virtual DOM - не является частью web API, копия всего DOM."
    },
    {
      "id": 42,
      "text": "Что такое условный рендеринг (Conditional Rendering)? Как его выполнить?",
      "hasOptions": false,
      "answer": "Условный рендеринг - это процесс отображения компонента на основе определенного условия. Например, если пользователь аутентифицирован, отображается один компонент, а если нет, то другой. Оператор if и цикл for не являются выражениями в JavaScript, поэтому их нельзя непосредственно использовать в JSX. Вместо этого, вы можете окружить ими JSX-код. Т.к. JSX не поддерживает if else то реализуется через логические условия или тернарным оператором."
    },
    {
      "id": 43,
      "text": "Что такое компонент-переключатель (Switching Component)?",
      "hasOptions": false,
      "answer": "Компонент-переключатель (Switching Component) - это компонент в React, который отображает один из нескольких компонентов в зависимости от определенного условия. Он может использоваться для выполнения условного рендеринга на основе нескольких условий. Основная идея, это структура в виде объекта в котором по ключам доступны компоненты. Получая пропсы, он вытягивает из них значения этого ключа, после чего по этому значению возвращает нужный компонент которому с помощью спред оператора передаются все пропсы."
    },
    {
      "id": 44,
      "text": "Как React обрабатывает, или ограничивает использование пропсов определенного типа?",
      "hasOptions": false,
      "answer": "PropTypes - это библиотека, которая позволяет определить типы пропсов для компонентов. Она предоставляет набор функций-валидаторов для различных типов данных (строки, числа, объекты и т.д.), которые могут быть использованы для проверки типов передаваемых пропсов. Если пропс имеет неверный тип, PropTypes выдаст предупреждение в консоли браузера. .defaultProps - дефолтные пропсы"
    },
    {
      "id": 45,
      "text": "Что такое строгий режим в React? Его преимущества?",
      "hasOptions": false,
      "answer": "Строгий режим (Strict Mode) в React - это специальный режим работы, который позволяет выявлять потенциальные проблемы в приложении на ранней стадии и предотвращать некоторые типы ошибок. Проверки осуществляются только в dev режиме и не влияют на продакшн сборку.\nПреимущества строгого режима в React:\nОшибки в компонентах и жизненном цикле компонентов будут выдаваться сразу на весь экран, а не в консоли браузера\nСтрогий режим помогает выявлять устаревшие методы и функции, которые могут быть удалены в будущих версиях React\nВ строгом режиме React обнаруживает некоторые потенциальные проблемы, связанные с использованием устаревших API и неопределенными значениями, что может помочь избежать ошибок при разработке.\nСтрогий режим может помочь оптимизировать производительность приложения, например, путем предотвращения ненужных перерисовок компонентов."
    },
    {
      "id": 46,
      "text": "Что такое «бурение пропсов» (Prop Drilling)? Как его избежать?",
      "hasOptions": false,
      "answer": "«Бурение пропсов» (Prop Drilling) - это ситуация, когда компоненты передают пропсы через несколько уровней вложенности, чтобы достичь компонента, который их действительно нуждается. Это может привести к неудобствам при разработке и поддержке кода, а также ухудшить читаемость и понимание кода."
    },
    {
      "id": 47,
      "text": "Что такое «опрос» (Polling)? Как его реализовать в React?",
      "hasOptions": false,
      "answer": "«Опрос» (Polling) - это процесс периодического запроса данных с сервера для обновления информации на странице без необходимости перезагрузки страницы. В React опрос можно реализовать с помощью использования функции setInterval() и useEffect для периодического вызова функции, которая отправляет запрос на сервер и обновляет состояние компонента с полученными данными."
    },
    {
      "id": 48,
      "text": "Что такое ReactDOMServer?",
      "hasOptions": false,
      "answer": "ReactDOMServer - это модуль React, который позволяет рендерить компоненты React на сервере в виде HTML-страницы. Это позволяет использовать React для создания приложений, которые могут быть полностью отрендерены на сервере и отправлены пользователю в виде готовой страницы, что улучшает SEO и ускоряет загрузку страницы за счет быстрой отрисовки на сервере."
    },
    {
      "id": 49,
      "text": "Что такое «ленивая» (Lazy) функция?",
      "hasOptions": false,
      "answer": "«Ленивая» (Lazy) функция в React - это функция, которая загружает компоненты только тогда, когда они действительно нужны, а не заранее. Это позволяет ускорить начальную загрузку приложения и уменьшить объем передаваемого кода. В React для создания «ленивых» функций используется функция `lazy()`, которая принимает функцию импорта компонента и возвращает новый компонент, который будет загружаться только при необходимости."
    },
    {
      "id": 50,
      "text": "Разница между рендерингом и монтированием?",
      "hasOptions": false,
      "answer": "Рендеринг (rendering) - это процесс создания виртуального дерева DOM на основе компонентов React. Во время рендеринга React создает виртуальное дерево DOM, которое представляет собой копию реального дерева DOM, но без фактического изменения элементов на странице. Повторный рендеринг получает инфу об уже смонтированном компоненте.\nМонтирование (mounting) - это процесс добавления виртуального дерева DOM на страницу. Когда React создает виртуальное дерево DOM, он еще не добавлен на страницу, т.е. первый рендеринг компонента и внедрение его в DOM . Этот процесс называется монтированием. Во время монтирования React создает реальный дерево DOM и добавляет его на страницу."
    },
    {
      "id": 51,
      "text": "Что такое сhildren?",
      "hasOptions": false,
      "answer": "Children (дети) в React - это свойство компонента, которое позволяет передавать другие компоненты или элементы внутрь текущего компонента в качестве дочерних элементов. Children могут быть переданы через JSX или через пропсы."
    },
    {
      "id": 52,
      "text": "Что такое события указателя (Pointer Events)?",
      "hasOptions": false,
      "answer": "События указателя (Pointer Events) - это API, которое позволяет отслеживать действия пользователя с помощью указателя на устройствах сенсорных экранов, мышей и стилусов. Оно предоставляет единый интерфейс для обработки событий указателя независимо от типа устройства, что упрощает разработку многоплатформенных приложений."
    },
    {
      "id": 53,
      "text": "Что такое инверсия наследования (Inheritance Inversion)?",
      "hasOptions": false,
      "answer": "Мы возвращаем класс, расширяющий WrappedComponent. Данная техника называется инверсией наследования, поскольку вместо расширения некоторого класса-усилителя (enhancer) с помощью WrappedComponent, последний сам пассивно расширяется. Отношения между ними напоминают инверсию."
    },
    {
      "id": 54,
      "text": "Как в React реализовать двустороннее связывание данных?",
      "hasOptions": false,
      "answer": "Это управляемый компонент, когда у нас стейт меняет то, что мы видим на экране, а изменение того, что мы видим на экране меняет стейт.\nДвустороннее связывание данных означает следующее:\nДанные, которые мы изменяем в представлении, обновляют состояние.\nДанные в состоянии обновляют представление."
    },
    {
      "id": 55,
      "text": "Разница между классовым и функциональным компонентами?",
      "hasOptions": false,
      "answer": "Классовые компоненты - это компоненты, которые наследуются от базового класса React.Component и имеют свое состояние (state) и методы жизненного цикла (lifecycle methods). Они обычно используются для более сложной логики и управления состоянием. Функциональные компоненты - это компоненты, которые являются простыми функциями, принимающими пропсы и возвращающими JSX. Они не имеют состояния и методов жизненного цикла, но могут использоваться для простых компонентов без необходимости управления состоянием. В React 16.8 были добавлены хуки (hooks), которые позволяют функциональным компонентам иметь состояние и использовать методы жизненного цикла, делая их более мощными и гибкими."
    },
    {
      "id": 56,
      "text": "Разница между useEffect(), componentDidMount()и useLayoutEffect()?",
      "hasOptions": false,
      "answer": "componentDidMount() вызывается только один раз после того, как компонент был добавлен в DOM, но перед отрисовкой в браузере. Он используется для выполнения действий, которые должны произойти только один раз при монтировании компонента, например, загрузка данных с сервера.\nНа основе render создается виртуальное дерево, но перед тем как отдать виртуальное дерево на отрисовку в браузер, вызывается componentDidMount и даже более того блокирует отрисовку в браузере, если внутри есть код блокирующий поток\nuseEffect() вызывается после каждого рендера компонента (включая первый рендер), т.е. после того как интерфейс отрисован на экране. Он может быть использован для выполнения действий при каждом рендере компонента или для эмуляции методов жизненного цикла, которые вызываются только один раз. Например, useEffect() может быть использован для выполнения действий при изменении пропсов или состояния компонента. Сначала на основе return создается виртуальное дерево, далее оно отдается на отрисовку в браузер и только после этого вызывается функция переданная в useEffect \nuseLayoutEffect() если нам нужно выполнить какой-то код до отрисовки в браузере, нам предоставили хук useLayoutEffect, интерфейс которого полностью совпадает с useEffect, но по очередности выполнения полностью совпадает с componentDidMount."
    },
    {
      "id": 57,
      "text": "Преимущества хуков?",
      "hasOptions": false,
      "answer": "Преимущества хуков в React заключаются в том, что они позволяют использовать состояние и другие функциональные возможности React в функциональных компонентах, а не только в классовых компонентах. Кроме того, хуки позволяют разделять логику компонента на более мелкие и переиспользуемые части, что улучшает читаемость и поддерживаемость кода. Легче тестировать отдельные функции компоненты. Также использование хуков позволяет избежать проблем с контекстом this, которые могут возникать при использовании классовых компонентов. Наконец, хуки предоставляют возможность более гибко управлять жизненным циклом компонента и его состоянием, что упрощает разработку и отладку приложений. Сложная логика может быть вынесена в кастомный хук."
    },
    {
      "id": 58,
      "text": "Недостатки хуков?",
      "hasOptions": false,
      "answer": "Основным недостатком хуков в React является то, что их использование может привести к более сложному и запутанному коду, если не следовать определенным правилам и практикам. Кроме того, некоторые разработчики могут испытывать трудности в понимании концепции хуков и их правильного использования, особенно если они ранее работали только с классовыми компонентами. Наконец, хуки не подходят для всех типов компонентов и задач, и иногда классовые компоненты могут быть более удобным и эффективным выбором. Нельзя вызывать в условиях и циклах. Не охватывают все варианты использования классов. Излишнее использование useMemeo и других только замедлят работу приложения."
    },
    {
      "id": 59,
      "text": "Что такое поднятие состояния вверх (Lifting State Up)?",
      "hasOptions": false,
      "answer": "Поднятие состояния вверх (Lifting State Up) - это паттерн в React, который позволяет передавать состояние от дочерних компонентов к родительским. Это делается путем определения общего состояния на более высоком уровне и передачи обработчиков для его изменения в дочерние компоненты через пропсы."
    },
    {
      "id": 60,
      "text": "Что делает метод shouldComponentUpdate?",
      "hasOptions": false,
      "answer": "Метод shouldComponentUpdate является жизненным циклом компонента в React и позволяет оптимизировать производительность приложения. Он вызывается перед обновлением компонента и позволяет контролировать, должен ли компонент быть перерисован или нет, без необходимости запускать механизм согласования в реакт, экономя тем самым ресурсы."
    },
    {
      "id": 61,
      "text": "Что такое useReducer()?",
      "hasOptions": false,
      "answer": "useReducer() - это хук, принимающий функцию редьюсер и начальное состояние в качестве аргументов, а возвращающий текущее состояние и диспетчер для отправки операций. Может заменить собой применение нескольких setState, сократив кол-во кода и вызываемых хуков."
    },
    {
      "id": 62,
      "text": "Как реализовать однократное выполнение операции при начальном рендеринге?",
      "hasOptions": false,
      "answer": "componentDidMount()\n useEffect(() => {}, [])"
    },
    {
      "id": 63,
      "text": "Что будет если вторым параметром useEffect передать [ ]",
      "hasOptions": false,
      "answer": "useEffect будет исполнятся только во время первого рендера"
    },
    {
      "id": 64,
      "text": "Что такое распределенный компонент?",
      "hasOptions": false,
      "answer": "Это компонент, который управляет своим внутренним состоянием, а логику рендеринга делегирует другому компоненту. Опрерует через children, отделяя таким образом логику компонентов друг от друга, но при этом передавая обработчики для изменения состояния в children."
    },
    {
      "id": 65,
      "text": "Расскажите о хуках useCallback(), useMemo(), useImperativeHandle(), useLayoutEffect()?",
      "hasOptions": false,
      "answer": "useCallback() - это хук, который позволяет оптимизировать производительность компонентов, которые передают функции в качестве пропсов. Он возвращает мемоизированную версию колбэка-функции, которая будет пересоздаваться только при изменении зависимостей. \n useMemo() - это хук, который позволяет мемоизировать результаты вычислений и использовать их повторно, если входные параметры не изменились. Он возвращает мемоизированное значение, которое будет пересчитываться только при изменении зависимостей. \n useImperativeHandle() - это хук, который позволяет экспортировать определенные методы из дочернего компонента в родительский компонент. Используется совместно с forwardRef \n useLayoutEffect() - это хук, который позволяет выполнять синхронный код после того, как DOM-дерево было обновлено, но перед тем, как браузер начнет рендерить изменения. Он используется для выполнения манипуляций с DOM-элементами, которые должны быть завершены до начала рендеринга."
    },
    {
      "id": 66,
      "text": "Чем React Router отличается от обычной маршрутизации?",
      "hasOptions": false,
      "answer": "React Router представляет собой библиотеку для маршрутизации в React-приложениях, которая позволяет создавать динамические маршруты без перезагрузки всей страницы, при этом запоминая историю и позволяя по ней перемещаться.  Она отличается от обычной маршрутизации тем, что работает на клиентской стороне и не требует обращения к серверу для получения новой страницы т.к. в SPA всего один html файл внутри которого вместо переходов по страницам просто перерисовываются компоненты."
    },
    {
      "id": 67,
      "text": "Что такое порталы в React?",
      "hasOptions": false,
      "answer": "Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент. Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки."
    },
    {
      "id": 68,
      "text": "Что будет если ничего не передавать вторым параметром в useEffect?",
      "hasOptions": false,
      "answer": "useEffect будет исполнятся при каждом изменении state"
    }
  ]
}
